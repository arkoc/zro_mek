<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6-DOF Anthropomorphic Arm Simulation (DH Parameters)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            display: flex;
            height: 100vh;
        }

        #container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        #controls {
            width: 350px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
        }

        #viewport {
            flex: 1;
            position: relative;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: #333;
            border-radius: 8px;
            border: 1px solid #555;
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            border-bottom: 1px solid #555;
            padding-bottom: 8px;
        }

        .joint-control {
            margin: 12px 0;
        }

        .joint-control label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #ccc;
        }

        .joint-control input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            background: #555;
            height: 6px;
            border-radius: 3px;
            outline: none;
        }

        .joint-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }

        .joint-control input[type="number"] {
            width: 80px;
            padding: 5px;
            border: 1px solid #555;
            background: #444;
            color: #fff;
            border-radius: 4px;
        }

        .dh-param {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .dh-param label {
            width: 60px;
            margin-right: 10px;
            font-size: 0.9em;
        }

        .dh-param input {
            flex: 1;
            padding: 5px;
            border: 1px solid #555;
            background: #444;
            color: #fff;
            border-radius: 4px;
        }

        .position-display {
            background: #1a4d1a;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .position-display div {
            margin: 5px 0;
            font-family: 'Courier New', monospace;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-weight: 500;
        }

        button:hover {
            background: #45a049;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>ðŸ¤– 6-DOF Robot Control</h2>
            
            <div class="control-group">
                <h3>Joint Angles</h3>
                <div class="joint-control">
                    <label>J1 - Base: <span id="j1-value">90Â°</span></label>
                    <input type="range" id="j1-slider" min="0" max="180" value="90">
                </div>
                <div class="joint-control">
                    <label>J2 - Shoulder: <span id="j2-value">90Â°</span></label>
                    <input type="range" id="j2-slider" min="0" max="180" value="90">
                </div>
                <div class="joint-control">
                    <label>J3 - Elbow: <span id="j3-value">90Â°</span></label>
                    <input type="range" id="j3-slider" min="0" max="180" value="90">
                </div>
                <div class="joint-control">
                    <label>J4 - Wrist Roll: <span id="j4-value">90Â°</span></label>
                    <input type="range" id="j4-slider" min="0" max="180" value="90">
                </div>
                <div class="joint-control">
                    <label>J5 - Wrist Pitch: <span id="j5-value">90Â°</span></label>
                    <input type="range" id="j5-slider" min="0" max="180" value="90">
                </div>
                <div class="joint-control">
                    <label>J6 - Wrist Yaw: <span id="j6-value">90Â°</span></label>
                    <input type="range" id="j6-slider" min="0" max="180" value="90">
                </div>
                <button onclick="homePosition()">HOME</button>
                <button onclick="randomPose()">Random Pose</button>
            </div>

            <div class="control-group">
                <h3>DH Parameters (mm)</h3>
                <div class="dh-param">
                    <label>DH_a2:</label>
                    <input type="number" id="dh-a2" value="150" onchange="updateDHParams()">
                    <span style="font-size: 0.8em; color: #aaa; margin-left: 10px;">hand1 - Upper arm</span>
                </div>
                <div class="dh-param">
                    <label>DH_a3:</label>
                    <input type="number" id="dh-a3" value="250" onchange="updateDHParams()">
                    <span style="font-size: 0.8em; color: #aaa; margin-left: 10px;">hand2 + connector_top - Forearm</span>
                </div>
                <div class="dh-param">
                    <label>DH_d6:</label>
                    <input type="number" id="dh-d6" value="50" onchange="updateDHParams()">
                    <span style="font-size: 0.8em; color: #aaa; margin-left: 10px;">tip + claw - Wrist extension</span>
                </div>
                <div class="dh-param">
                    <label>DH_d1:</label>
                    <input type="number" id="dh-d1" value="10" onchange="updateDHParams()">
                    <span style="font-size: 0.8em; color: #aaa; margin-left: 10px;">base -> connector_bottom - Base height</span>
                </div>
            </div>

            <div class="control-group">
                <h3>Position & Orientation</h3>
                <div class="position-display">
                    <div>X: <span id="pos-x">0.00</span> mm</div>
                    <div>Y: <span id="pos-y">0.00</span> mm</div>
                    <div>Z: <span id="pos-z">0.00</span> mm</div>
                    <div>Approach Vector:</div>
                    <div>AX: <span id="approach-x">0.00</span></div>
                    <div>AY: <span id="approach-y">0.00</span></div>
                    <div>AZ: <span id="approach-z">1.00</span></div>
                </div>
            </div>
        </div>

        <div id="viewport">
            <div id="info">
                Mouse: Left=Orbit, Right=Pan, Wheel=Zoom<br>
                DH Parameters: a2 (upper arm), a3 (forearm), d6 (wrist ext), d1 (base height)<br>
                Coordinate System: X(Red), Y(Green), Z(Blue)
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let robot = {};
        let joints = [];
        
        // DH Parameters (configurable) - matching Arduino code structure exactly
        let dhParams = {
            a2: 150,   // DH_a2: hand1 - Upper arm length (mm)
            a3: 250,   // DH_a3: hand2 + connector_top - Forearm length (mm)
            d6: 50,    // DH_d6: tip + claw (minus actual claws) - Wrist extension (mm)
            d1: 10     // DH_d1: base -> connector_bottom - Base height (mm)
        };
        
        // Joint angles (degrees)
        let jointAngles = [90, 90, 90, 90, 90, 90];
        
        // Initialize the 3D scene
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(300, 200, 300);
            
            // Renderer setup
            const viewport = document.getElementById('viewport');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            viewport.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 200, 100);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add coordinate system with grid
            addCoordinateSystem();
            
            // Create robot
            createRobot();
            
            // Setup controls
            setupControls();
            
            // Start animation loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function addCoordinateSystem() {
            // Create coordinate grid with labeled axes
            const gridSize = 400;
            const gridDivisions = 20;
            
            // XZ plane grid (horizontal - ground plane) - centered at origin
            const gridXZ = new THREE.GridHelper(gridSize, gridDivisions, 0x444444, 0x222222);
            gridXZ.position.set(0, 0, 0); // Keep at origin
            scene.add(gridXZ);
            
            // XY plane grid (vertical - shows X vs Y/height) - positioned behind robot
            const gridXY = new THREE.GridHelper(gridSize, gridDivisions, 0x333333, 0x111111);
            gridXY.rotateX(Math.PI / 2); // Rotate to be vertical
            gridXY.position.set(0, gridSize/4, -gridSize/4); // Move back and up
            scene.add(gridXY);
            
            // YZ plane grid (vertical - shows depth vs height) - positioned to the side
            const gridYZ = new THREE.GridHelper(gridSize, gridDivisions, 0x333333, 0x111111);
            gridYZ.rotateZ(Math.PI / 2); // Rotate to be vertical
            gridYZ.position.set(-gridSize/4, gridSize/4, 0); // Move left and up
            scene.add(gridYZ);
            
            // Main coordinate axes with arrows
            const arrowLength = 120;
            const arrowX = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), arrowLength, 0xff0000, 25, 15);
            const arrowY = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), arrowLength, 0x00ff00, 25, 15);
            const arrowZ = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), arrowLength, 0x0000ff, 25, 15);
            scene.add(arrowX);
            scene.add(arrowY);
            scene.add(arrowZ);
            
            // Add grid markings and labels
            addGridMarkings();
        }
        
        function addGridMarkings() {
            // Add measurement marks every 50mm along axes
            const markInterval = 50;
            const maxDistance = 200;
            
            for (let i = markInterval; i <= maxDistance; i += markInterval) {
                // X-axis marks (Red)
                addAxisMark(i, 0, 0, 0xff0000, `${i}`);
                addAxisMark(-i, 0, 0, 0xff0000, `${-i}`);
                
                // Y-axis marks (Green)  
                addAxisMark(0, i, 0, 0x00ff00, `${i}`);
                
                // Z-axis marks (Blue)
                addAxisMark(0, 0, i, 0x0000ff, `${i}`);
                addAxisMark(0, 0, -i, 0x0000ff, `${-i}`);
            }
            
            // Add origin marker
            const originGeometry = new THREE.SphereGeometry(5, 8, 8);
            const originMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const originMesh = new THREE.Mesh(originGeometry, originMaterial);
            scene.add(originMesh);
        }
        
        function addAxisMark(x, y, z, color, label) {
            // Small tick mark
            const tickGeometry = new THREE.BoxGeometry(2, 2, 2);
            const tickMaterial = new THREE.MeshLambertMaterial({ color: color });
            const tick = new THREE.Mesh(tickGeometry, tickMaterial);
            tick.position.set(x, y, z);
            scene.add(tick);
            
            // Create text sprite for label
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.fillText(label, 32, 20);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y + 8, z);
            sprite.scale.set(20, 10, 1);
            scene.add(sprite);
        }
        
        
        function createRobot() {
            // Clear existing robot
            if (robot.group) {
                scene.remove(robot.group);
            }
            
            robot.group = new THREE.Group();
            robot.links = [];
            robot.joints = [];
            
            // Base platform (large rectangular base)
            const baseGeometry = new THREE.BoxGeometry(80, 20, 60);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 10;
            robot.group.add(base);
            
            // Create realistic robot structure
            createRealisticRobot();
            
            scene.add(robot.group);
            updateRobot();
        }
        
        function createRealisticRobot() {
            robot.joints = [];
            
            // J1 - Base rotation joint (vertical cylinder) - attached to base
            const j1Group = new THREE.Group();
            const j1Housing = new THREE.BoxGeometry(40, 35, 40);
            const j1Mesh = new THREE.Mesh(j1Housing, new THREE.MeshLambertMaterial({ color: 0x909090 }));
            j1Mesh.position.y = 17.5; // Half height above base
            j1Group.add(j1Mesh);
            j1Group.position.set(0, 20, 0); // On top of base
            robot.joints.push(j1Group);
            robot.group.add(j1Group);
            
            // J2 - Shoulder joint (horizontal pivot) - child of J1
            const j2Group = new THREE.Group();
            // Shoulder housing
            const shoulderGeometry = new THREE.BoxGeometry(25, 30, 50);
            const shoulderMesh = new THREE.Mesh(shoulderGeometry, new THREE.MeshLambertMaterial({ color: 0x808080 }));
            j2Group.add(shoulderMesh);
            // Upper arm link (DH_a2)
            const upperArmGeometry = new THREE.BoxGeometry(15, dhParams.a2, 20);
            const upperArmMesh = new THREE.Mesh(upperArmGeometry, new THREE.MeshLambertMaterial({ color: 0x707070 }));
            upperArmMesh.position.y = dhParams.a2/2;
            j2Group.add(upperArmMesh);
            j2Group.position.set(0, dhParams.d1 + 25, 0); // Base height includes DH_d1
            robot.joints.push(j2Group);
            j1Group.add(j2Group); // J2 is child of J1
            
            // J3 - Elbow joint - child of J2
            const j3Group = new THREE.Group();
            // Elbow housing
            const elbowGeometry = new THREE.BoxGeometry(20, 20, 30);
            const elbowMesh = new THREE.Mesh(elbowGeometry, new THREE.MeshLambertMaterial({ color: 0x808080 }));
            j3Group.add(elbowMesh);
            // Forearm link (DH_a3)
            const forearmGeometry = new THREE.BoxGeometry(10, dhParams.a3, 15);
            const forearmMesh = new THREE.Mesh(forearmGeometry, new THREE.MeshLambertMaterial({ color: 0x707070 }));
            forearmMesh.position.y = dhParams.a3/2;
            j3Group.add(forearmMesh);
            j3Group.position.set(0, dhParams.a2, 0); // At end of upper arm (a2)
            robot.joints.push(j3Group);
            j2Group.add(j3Group); // J3 is child of J2
            
            // J4 - Wrist roll joint - child of J3
            const j4Group = new THREE.Group();
            const wrist1Geometry = new THREE.BoxGeometry(18, 20, 22);
            const wrist1Mesh = new THREE.Mesh(wrist1Geometry, new THREE.MeshLambertMaterial({ color: 0x606060 }));
            j4Group.add(wrist1Mesh);
            j4Group.position.set(0, dhParams.a3, 0); // At end of forearm (a3)
            robot.joints.push(j4Group);
            j3Group.add(j4Group); // J4 is child of J3
            
            // J5 - Wrist pitch joint - child of J4
            const j5Group = new THREE.Group();
            const wrist2Geometry = new THREE.BoxGeometry(16, 20, 25);
            const wrist2Mesh = new THREE.Mesh(wrist2Geometry, new THREE.MeshLambertMaterial({ color: 0x606060 }));
            j5Group.add(wrist2Mesh);
            j5Group.position.set(0, 20, 0); // Fixed offset for wrist assembly
            robot.joints.push(j5Group);
            j4Group.add(j5Group); // J5 is child of J4
            
            // J6 - Wrist yaw joint + End-effector - child of J5
            const j6Group = new THREE.Group();
            const wrist3Geometry = new THREE.BoxGeometry(14, 20, 18);
            const wrist3Mesh = new THREE.Mesh(wrist3Geometry, new THREE.MeshLambertMaterial({ color: 0x505050 }));
            j6Group.add(wrist3Mesh);
            
            // End-effector/gripper (represents d6 extension in DH parameters)
            const gripperGeometry = new THREE.BoxGeometry(8, dhParams.d6, 12);
            const gripperMesh = new THREE.Mesh(gripperGeometry, new THREE.MeshLambertMaterial({ color: 0x4CAF50 }));
            gripperMesh.position.y = dhParams.d6/2;
            j6Group.add(gripperMesh);
            
            // Add tip indicator (small red sphere at the very tip)
            const tipGeometry = new THREE.SphereGeometry(3, 8, 8);
            const tipMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            const tipMesh = new THREE.Mesh(tipGeometry, tipMaterial);
            tipMesh.position.y = dhParams.d6;  // At end of d6 extension
            j6Group.add(tipMesh);
            
            j6Group.position.set(0, 20, 0); // Fixed offset for wrist assembly
            robot.joints.push(j6Group);
            j5Group.add(j6Group); // J6 is child of J5
        }
        
        
        function updateRobot() {
            // Apply joint rotations in the kinematic chain
            // Since joints are now properly connected as parent-child, 
            // we only need to set the rotation of each joint
            
            for (let i = 0; i < robot.joints.length; i++) {
                const joint = robot.joints[i];
                const theta = (jointAngles[i] - 90) * Math.PI / 180;
                
                // Reset rotation
                joint.rotation.set(0, 0, 0);
                
                // Apply rotation based on joint type
                if (i === 0) {
                    // J1 - Base rotation around Y-axis (vertical)
                    joint.rotation.y = theta;
                } else if (i === 1) {
                    // J2 - Shoulder rotation around Z-axis (horizontal)
                    joint.rotation.z = theta;
                } else if (i === 2) {
                    // J3 - Elbow rotation around Z-axis
                    joint.rotation.z = theta;
                } else if (i === 3) {
                    // J4 - Wrist roll around Y-axis
                    joint.rotation.y = theta;
                } else if (i === 4) {
                    // J5 - Wrist pitch around Z-axis
                    joint.rotation.z = theta;
                } else if (i === 5) {
                    // J6 - Wrist yaw around Y-axis
                    joint.rotation.y = theta;
                }
            }
            
            // Update position display
            updatePositionDisplay();
        }
        
        
        function updatePositionDisplay() {
            // Calculate end-effector position by tracing through the kinematic chain
            // This directly matches the actual 3D robot tip position
            
            // Get the end-effector (gripper tip) world position from the 3D scene
            const endEffectorJoint = robot.joints[5]; // J6 joint with gripper
            const worldPosition = new THREE.Vector3();
            const worldMatrix = new THREE.Matrix4();
            
            // Get the gripper mesh (green part) which is the actual tip
            const gripperMesh = endEffectorJoint.children.find(child => 
                child.material && child.material.color.getHex() === 0x4CAF50
            );
            
            if (gripperMesh) {
                // Get the tip position (top of gripper, at d6 extension)
                const tipPosition = new THREE.Vector3(0, dhParams.d6, 0);
                gripperMesh.updateMatrixWorld(true);
                tipPosition.applyMatrix4(gripperMesh.matrixWorld);
                
                worldPosition.copy(tipPosition);
            } else {
                // Fallback: use J6 joint center
                endEffectorJoint.updateMatrixWorld(true);
                worldPosition.setFromMatrixPosition(endEffectorJoint.matrixWorld);
            }
            
            // Calculate approach vector (direction the end-effector is pointing)
            const approachDirection = new THREE.Vector3(0, 1, 0); // Local Y-axis (gripper direction)
            endEffectorJoint.updateMatrixWorld(true);
            approachDirection.transformDirection(endEffectorJoint.matrixWorld);
            approachDirection.normalize();
            
            // Update display with actual robot tip position
            document.getElementById('pos-x').textContent = worldPosition.x.toFixed(2);
            document.getElementById('pos-y').textContent = worldPosition.z.toFixed(2); // Z becomes Y in robot coordinates
            document.getElementById('pos-z').textContent = worldPosition.y.toFixed(2); // Y becomes Z in robot coordinates
            document.getElementById('approach-x').textContent = approachDirection.x.toFixed(3);
            document.getElementById('approach-y').textContent = approachDirection.z.toFixed(3);
            document.getElementById('approach-z').textContent = approachDirection.y.toFixed(3);
        }
        
        function setupControls() {
            for (let i = 1; i <= 6; i++) {
                const slider = document.getElementById(`j${i}-slider`);
                const valueSpan = document.getElementById(`j${i}-value`);
                
                slider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    jointAngles[i-1] = value;
                    valueSpan.textContent = value + 'Â°';
                    updateRobot();
                });
            }
        }
        
        function updateDHParams() {
            dhParams.a2 = parseFloat(document.getElementById('dh-a2').value);
            dhParams.a3 = parseFloat(document.getElementById('dh-a3').value);
            dhParams.d6 = parseFloat(document.getElementById('dh-d6').value);
            dhParams.d1 = parseFloat(document.getElementById('dh-d1').value);
            
            // Recreate robot with new DH parameters
            createRobot();
        }
        
        function homePosition() {
            for (let i = 0; i < 6; i++) {
                jointAngles[i] = 90;
                document.getElementById(`j${i+1}-slider`).value = 90;
                document.getElementById(`j${i+1}-value`).textContent = '90Â°';
            }
            updateRobot();
        }
        
        function randomPose() {
            for (let i = 0; i < 6; i++) {
                const angle = Math.floor(Math.random() * 181);
                jointAngles[i] = angle;
                document.getElementById(`j${i+1}-slider`).value = angle;
                document.getElementById(`j${i+1}-value`).textContent = angle + 'Â°';
            }
            updateRobot();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            const viewport = document.getElementById('viewport');
            camera.aspect = viewport.clientWidth / viewport.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>